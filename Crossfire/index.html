<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>CrossFire CLI - Documentation</title>
<link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap" rel="stylesheet">
<style>
/* Base & Reset */
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
    text-decoration: none;
}
html, body {
    font-family: 'Roboto', sans-serif;
    background-color: #0d1117;
    color: #c9d1d9;
    line-height: 1.6;
    scroll-behavior: smooth;
    position: relative;
    z-index: 1;
    overflow-x: hidden;
}
:root {
    --primary-color: #58a6ff;
    --secondary-color: #8b949e;
    --background-dark: #010409;
    --background-light: #161b22;
    --border-color: #30363d;
    --success-color: #3fb950;
    --warning-color: #d29922;
    --danger-color: #f85149;
}

/* Container */
.container {
    max-width: 1200px;
    margin: auto;
    padding: 2rem;
}
header {
    text-align: center;
    margin-bottom: 2.5rem;
}
header h1 {
    font-size: 3.5rem;
    color: var(--primary-color);
    margin-bottom: 0.5rem;
    font-weight: 700;
    letter-spacing: -1px;
}
header p {
    color: var(--secondary-color);
    font-size: 1.2rem;
}

/* Table of Contents */
.toc {
    margin: 1.5rem 0 3rem 0;
    padding: 1.5rem;
    background-color: var(--background-light);
    border: 1px solid var(--border-color);
    border-radius: 12px;
}
.toc h2 {
    color: var(--primary-color);
    margin-bottom: 1.5rem;
    text-align: center;
    font-size: 1.8rem;
    font-weight: 500;
}
.toc ul {
    list-style: none;
    padding-left: 0;
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
    gap: 10px;
}
.toc ul li {
    margin-bottom: 0.75rem;
}
.toc a {
    color: var(--secondary-color);
    transition: all 0.3s ease;
    display: flex;
    align-items: center;
    gap: 8px;
}
.toc a:hover {
    color: var(--primary-color);
    transform: translateX(5px);
}
.toc a::before {
    content: '→';
    display: inline-block;
    color: var(--primary-color);
    font-size: 1.2em;
    font-weight: bold;
    opacity: 0.7;
    transition: transform 0.3s ease;
}
.toc a:hover::before {
    transform: rotate(45deg);
    opacity: 1;
}

/* Sections */
.section {
    margin-bottom: 3.5rem;
    background-color: var(--background-light);
    padding: 2rem;
    border-radius: 12px;
    border: 1px solid var(--border-color);
}
.section h2 {
    color: var(--primary-color);
    margin-bottom: 1.5rem;
    font-size: 2rem;
    font-weight: 500;
    border-bottom: 2px solid var(--primary-color);
    padding-bottom: 0.5rem;
    display: inline-block;
}
.section h3 {
    color: var(--secondary-color);
    margin: 1.5rem 0 1rem;
    font-size: 1.5rem;
    font-weight: 500;
}
.section p, .section li {
    font-size: 1rem;
    color: #c9d1d9;
    margin-bottom: 0.75rem;
}
.section pre {
    background: var(--background-dark);
    border: 1px solid var(--border-color);
    padding: 1.5rem;
    border-radius: 8px;
    overflow-x: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
}
.section code {
    color: var(--success-color);
    font-family: 'Courier New', Courier, monospace;
    font-size: 0.9em;
}
.section table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 1.5rem;
    text-align: left;
}
.section table, .section th, .section td {
    border: 1px solid var(--border-color);
}
.section th, .section td {
    padding: 1rem;
    color: var(--secondary-color);
}
.section th {
    color: var(--primary-color);
    background: #111;
    font-weight: 500;
}
.section ul, .section ol {
    padding-left: 2rem;
}
.section ul li {
    list-style: disc;
}
.section ol li {
    list-style: decimal;
}

/* Icons for lists */
.section ul li::marker {
    color: var(--success-color);
}
.section ol li::marker {
    color: var(--primary-color);
}

/* CTA Buttons */
.cta-buttons {
    display: flex;
    justify-content: center;
    gap: 1.5rem;
    margin-bottom: 2rem;
}
.cta-buttons a {
    padding: 0.75rem 2rem;
    border-radius: 9999px;
    background: var(--primary-color);
    color: var(--background-dark);
    border: 1px solid var(--primary-color);
    font-weight: 700;
    transition: all 0.3s ease;
}
.cta-buttons a:hover {
    background: transparent;
    color: var(--primary-color);
}

/* Footer */
footer {
    text-align: center;
    padding: 2rem;
    margin-top: 3rem;
    border-top: 1px solid var(--border-color);
    color: var(--secondary-color);
    font-size: 0.9rem;
}
footer a {
    color: var(--primary-color);
    transition: color 0.3s ease;
}
footer a:hover {
    color: var(--success-color);
}

/* Media Queries */
@media (max-width: 768px) {
    .container {
        padding: 1rem;
    }
    header h1 {
        font-size: 2.5rem;
    }
    .toc ul {
        grid-template-columns: 1fr;
    }
    .section h2 {
        font-size: 1.75rem;
    }
}
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>CrossFire CLI Documentation</h1>
    <p>A Universal Package Manager for a Unified World</p>
  </header>

  <div class="toc">
    <h2>Table of Contents</h2>
    <ul>
      <li><a href="#overview">Overview</a></li>
      <li><a href="#architecture--design">Architecture & Design</a></li>
      <li><a href="#installation--setup">Installation & Setup</a></li>
      <li><a href="#core-components">Core Components</a></li>
      <li><a href="#command-reference">Command Reference</a></li>
      <li><a href="#package-manager-integration">Package Manager Integration</a></li>
      <li><a href="#system-detection">System Detection</a></li>
      <li><a href="#advanced-features">Advanced Features</a></li>
      <li><a href="#configuration">Configuration</a></li>
      <li><a href="#error-handling--recovery">Error Handling & Recovery</a></li>
      <li><a href="#security-considerations">Security Considerations</a></li>
      <li><a href="#performance--optimization">Performance & Optimization</a></li>
      <li><a href="#troubleshooting">Troubleshooting</a></li>
      <li><a href="#development--extension">Development & Extension</a></li>
    </ul>
  </div>

  <div class="section" id="overview">
    <h2>Overview</h2>
    <p><b>CrossFire</b> is a universal package manager CLI tool designed to unify package management across different operating systems and package ecosystems. Version 3.0.0 represents a stable, production-ready implementation that intelligently detects available package managers and provides a consistent interface for package operations.</p>
    
    <h3>Key Features</h3>
    <ul>
      <li><b>Universal Package Management</b>: Install packages across 13+ different package managers</li>
      <li><b>Intelligent Manager Selection</b>: Automatically chooses the best package manager for each package</li>
      <li><b>Cross-Platform Support</b>: Works on Windows, macOS, and Linux distributions</li>
      <li><b>Concurrent Operations</b>: Multi-threaded downloads and parallel manager updates</li>
      <li><b>Self-Updating</b>: Built-in update mechanism with integrity verification</li>
      <li><b>System Health Monitoring</b>: Comprehensive health checks and statistics</li>
      <li><b>Robust Error Handling</b>: Retry mechanisms and graceful failure recovery</li>
      <li><b>JSON Output Mode</b>: Machine-parseable output for automation</li>
    </ul>
    
    <h3>Supported Package Managers</h3>
    <table>
      <thead>
        <tr>
          <th>Manager</th>
          <th>Platforms</th>
          <th>Package Types</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><b>pip</b></td>
          <td>All</td>
          <td>Python packages</td>
        </tr>
        <tr>
          <td><b>npm</b></td>
          <td>All</td>
          <td>Node.js packages</td>
        </tr>
        <tr>
          <td><b>Homebrew</b></td>
          <td>macOS, Linux</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>APT</b></td>
          <td>Debian/Ubuntu</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>DNF</b></td>
          <td>Fedora/RHEL</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>YUM</b></td>
          <td>CentOS/RHEL</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>Pacman</b></td>
          <td>Arch Linux</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>Zypper</b></td>
          <td>openSUSE</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>APK</b></td>
          <td>Alpine Linux</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>Chocolatey</b></td>
          <td>Windows</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>Winget</b></td>
          <td>Windows</td>
          <td>System packages</td>
        </tr>
        <tr>
          <td><b>Snap</b></td>
          <td>Linux</td>
          <td>Universal packages</td>
        </tr>
        <tr>
          <td><b>Flatpak</b></td>
          <td>Linux</td>
          <td>Desktop applications</td>
        </tr>
      </tbody>
    </table>
  </div>
  
  <div class="section" id="architecture--design">
    <h2>Architecture & Design</h2>
    
    <h3>Core Architecture</h3>
    <p>CrossFire follows a modular architecture with clear separation of concerns:</p>
    <pre><code>CrossFire
├── Core Components
│   ├── Logging System (Colors, LogCfg)
│   ├── Command Execution (RunResult, run_command)
│   ├── System Detection (OS, distro, architecture)
│   └── Configuration Management
├── Package Manager Layer
│   ├── Manager Detection & Status
│   ├── Installation Handlers
│   ├── Removal Handlers
│   └── Update Handlers
├── CLI Interface
│   ├── Argument Parsing
│   ├── Command Routing
│   └── Output Formatting
└── Advanced Features
    ├── Self-Update System
    ├── Health Monitoring
    ├── Statistics Collection
    └── System Cleanup</code></pre>
    
    <h3>Design Principles</h3>
    <ol>
      <li><b>Fail-Safe Operations</b>: Always attempt graceful degradation</li>
      <li><b>User Experience First</b>: Clear, actionable feedback for all operations</li>
      <li><b>Platform Agnostic</b>: Write once, run everywhere approach</li>
      <li><b>Security by Default</b>: Validate all external inputs and downloads</li>
      <li><b>Performance Optimized</b>: Use concurrency where beneficial</li>
      <li><b>Extensible</b>: Easy to add new package managers and features</li>
    </ol>
    
    <h3>Threading Model</h3>
    <p>CrossFire uses Python's <code>concurrent.futures.ThreadPoolExecutor</code> for:</p>
    <ul>
      <li>Parallel package manager status checks</li>
      <li>Concurrent manager updates (max 4 workers)</li>
      <li>Multi-chunk downloads for large files</li>
      <li>Bulk package operations</li>
    </ul>
  </div>
  
  <div class="section" id="installation--setup">
    <h2>Installation & Setup</h2>
    
    <h3>Prerequisites</h3>
    <ul>
      <li><b>Python 3.7+</b> (CrossFire is written in Python)</li>
      <li><b>Internet connection</b> (for downloads and updates)</li>
      <li><b>Administrator/root privileges</b> (for some package managers)</li>
    </ul>
    
    <h3>Quick Start</h3>
    <ol>
      <li><b>Download CrossFire</b>:
        <pre><code>curl -O https://raw.githubusercontent.com/BCAS-Team/CrossFire/main/CrossFireL/crossfire.py</code></pre>
      </li>
      <li><b>Make executable</b> (Unix-like systems):
        <pre><code>chmod +x crossfire.py</code></pre>
      </li>
      <li><b>Run initial setup</b>:
        <pre><code>python crossfire.py --setup</code></pre>
      </li>
    </ol>
    
    <h3>What --setup Does</h3>
    <p>The setup process performs several critical operations:</p>
    <ol>
      <li><b>PATH Configuration</b>:
        <ul>
          <li>Detects your shell (bash, zsh, fish)</li>
          <li>Adds CrossFire directory to PATH in appropriate RC file</li>
          <li>Handles shell-specific syntax differences</li>
        </ul>
      </li>
      <li><b>Launcher Installation</b>:
        <ul>
          <li><b>Unix/Linux/macOS</b>: Creates executable script in <code>~/.local/bin</code> or <code>/usr/local/bin</code></li>
          <li><b>Windows</b>: Creates <code>.bat</code> file in script directory</li>
          <li>Tests launcher functionality before confirming success</li>
        </ul>
      </li>
      <li><b>Shell Detection Logic</b>:
        <pre><code>def _get_shell_rc_file() -> str:
    shell = os.environ.get("SHELL", "")
    home = os.path.expanduser("~")

    if shell.endswith("zsh"):
        return os.path.join(home, ".zshrc")
    elif shell.endswith("bash"):
        return os.path.join(home, ".bashrc")  # Linux
        # or .bash_profile on macOS
    elif shell.endswith("fish"):
        return os.path.join(home, ".config", "fish", "config.fish")
    else:
        return os.path.join(home, ".profile")  # Fallback</code></pre>
      </li>
    </ol>
    
    <h3>Manual Installation</h3>
    <p>For environments where automatic setup isn't suitable:</p>
    <ol>
      <li><b>Place script in desired location</b></li>
      <li><b>Add to PATH manually</b>:
        <pre><code>export PATH="/path/to/crossfire:$PATH"</code></pre>
      </li>
      <li><b>Create alias</b> (alternative):
        <pre><code>alias crossfire='python /path/to/crossfire.py'</code></pre>
      </li>
    </ol>
  </div>
  
  <div class="section" id="core-components">
    <h2>Core Components</h2>
    
    <h3>Logging System</h3>
    <p>CrossFire implements a sophisticated logging system with multiple output modes:</p>
    
    <h4>LogCfg Class</h4>
    <pre><code>@dataclass
class LogCfg:
    quiet: bool = False      # Suppress non-error output
    verbose: bool = False    # Show detailed operation info
    json_mode: bool = False  # Machine-readable JSON output</code></pre>
    
    <h4>Color Support Detection</h4>
    <p>The system intelligently detects terminal color support:</p>
    <pre><code>def _fmt(msg: str, typ: str) -> str:
    supports_color = (
        hasattr(sys.stdout, 'isatty') and sys.stdout.isatty() and
        os.environ.get('TERM', '').lower() != 'dumb' and
        (OS_NAME != "Windows" or os.environ.get("FORCE_COLOR") or
         os.environ.get("ANSICON") or "ANSI" in os.environ.get("TERM", ""))
    )</code></pre>
    
    <h4>Log Levels</h4>
    <ul>
      <li><b>INFO</b>: General information (blue)</li>
      <li><b>SUCCESS</b>: Successful operations (green)</li>
      <li><b>WARNING</b>: Non-fatal issues (yellow)</li>
      <li><b>ERROR</b>: Fatal errors (red)</li>
      <li><b>MUTED</b>: Secondary information (gray)</li>
    </ul>
    
    <h4>JSON Output Mode</h4>
    <p>When <code>--json</code> flag is used, all output switches to structured JSON:</p>
    <pre><code>{
  "level": "info",
  "msg": "Installing package: numpy",
  "ts": 1703123456.789,
  "package": "numpy",
  "manager": "pip"
}</code></pre>
    
    <h3>Command Execution System</h3>
    
    <h4>RunResult Dataclass</h4>
    <pre><code>@dataclass
class RunResult:
    ok: bool      # True if command succeeded (return code 0)
    code: int     # Actual return code
    out: str      # stdout content
    err: str      # stderr content</code></pre>
    
    <h4>Command Parsing</h4>
    <p>The <code>_split_cmd</code> function handles both string and list command formats:</p>
    <pre><code>def _split_cmd(cmd: str | List[str]) -> List[str]:
    if isinstance(cmd, list):
        return cmd
    import shlex
    try:
        return shlex.split(cmd)  # Properly handle quoted arguments
    except ValueError:
        return cmd.split()       # Fallback for simple cases</code></pre>
    
    <h4>Execution Features</h4>
    <ul>
      <li><b>Timeout Protection</b>: Prevents hanging on unresponsive commands</li>
      <li><b>Retry Mechanism</b>: Exponential backoff for transient failures</li>
      <li><b>Environment Control</b>: Isolated environment variables</li>
      <li><b>Shell Detection</b>: Automatic shell usage for complex commands</li>
      <li><b>Cross-Platform</b>: Handles Windows-specific creation flags</li>
    </ul>
    
    <h4>Shell Command Detection</h4>
    <p>CrossFire automatically determines when to use shell mode:</p>
    <pre><code>if shell or (isinstance(cmd, str) and any(op in cmd for op in ['&&', '||', ';', '|', '>', '<'])):
    shell = True</code></pre>
    
    <h3>System Detection</h3>
    
    <h4>Operating System Detection</h4>
    <pre><code>OS_NAME = platform.system()      # Windows, Darwin, Linux
ARCH = platform.architecture()[0] # 32bit, 64bit</code></pre>
    
    <h4>Distribution Detection</h4>
    <p>CrossFire uses the <code>distro</code> library for Linux distribution detection:</p>
    <pre><code>try:
    import distro
    DISTRO_NAME = distro.id()      # ubuntu, fedora, arch, etc.
    DISTRO_VERSION = distro.version()
except Exception:
    # Fallback to platform-specific detection</code></pre>
    
    <h4>Architecture-Aware Operations</h4>
    <p>The system adapts behavior based on detected architecture:</p>
    <ul>
      <li>Package manager availability varies by architecture</li>
      <li>Some packages have architecture-specific names</li>
      <li>Installation paths differ between 32-bit and 64-bit systems</li>
    </ul>
  </div>
  
  <div class="section" id="command-reference">
    <h2>Command Reference</h2>
    
    <h3>Basic Usage</h3>
    <pre><code>crossfire [OPTIONS] [COMMAND]</code></pre>
    
    <h3>Global Options</h3>
    <table>
      <thead>
        <tr>
          <th>Option</th>
          <th>Description</th>
          <th>Example</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>--version</code></td>
          <td>Show version information</td>
          <td><code>crossfire --version</code></td>
        </tr>
        <tr>
          <td><code>--json</code></td>
          <td>JSON output mode</td>
          <td><code>crossfire --json --list-managers</code></td>
        </tr>
        <tr>
          <td><code>-q, --quiet</code></td>
          <td>Suppress non-error output</td>
          <td><code>crossfire -q -i package</code></td>
        </tr>
        <tr>
          <td><code>-v, --verbose</code></td>
          <td>Detailed operation logs</td>
          <td><code>crossfire -v -i package</code></td>
        </tr>
        <tr>
          <td><code>--manager NAME</code></td>
          <td>Force specific manager</td>
          <td><code>crossfire -i numpy --manager pip</code></td>
        </tr>
      </tbody>
    </table>
    
    <h3>Package Operations</h3>
    
    <h4>Installation</h4>
    <pre><code># Auto-detect best manager
crossfire -i package_name

# Force specific manager
crossfire -i package_name --manager pip

# Install from requirements file
crossfire --install-from requirements.txt

# Install with specific manager preference
crossfire --install-from package_list.txt --manager npm</code></pre>
    
    <h4>Package Search</h4>
    <pre><code># Search all available managers
crossfire -s search_term

# Search specific manager
crossfire -s search_term --manager pip

# JSON output for automation
crossfire --json -s search_term</code></pre>
    
    <h4>Package Information</h4>
    <pre><code># Get package details
crossfire --info package_name

# Manager-specific info
crossfire --info package_name --manager npm

# JSON format
crossfire --json --info package_name</code></pre>
    
    <h4>Package Removal</h4>
    <pre><code># Remove package (auto-detect manager)
crossfire -r package_name

# Remove with specific manager
crossfire -r package_name --manager pip</code></pre>
    
    <h3>System Management</h3>
    
    <h4>Manager Status</h4>
    <pre><code># List all managers and status
crossfire --list-managers

# JSON format
crossfire --json --list-managers</code></pre>
    
    <h4>Manager Updates</h4>
    <pre><code># Update all managers
crossfire -um ALL

# Update specific manager
crossfire -um pip

# Verbose update with details
crossfire -v -um ALL</code></pre>
    
    <h4>System Cleanup</h4>
    <pre><code># Clean all package caches
crossfire --cleanup

# JSON output
crossfire --json --cleanup</code></pre>
    
    <h4>Health Check</h4>
    <pre><code># Comprehensive system health check
crossfire --health-check

# JSON format for monitoring
crossfire --json --health-check</code></pre>
    
    <h4>System Statistics</h4>
    <pre><code># Show system and package statistics
crossfire --stats

# JSON format
crossfire --json --stats</code></pre>
    
    <h3>Export/Import</h3>
    
    <h4>Export Package Lists</h4>
    <pre><code># Export pip packages
crossfire --export pip

# Export to file
crossfire --export pip -o requirements.txt

# Export npm global packages
crossfire --export npm -o package-list.txt</code></pre>
    
    <h3>Self-Maintenance</h3>
    
    <h4>Self-Update</h4>
    <pre><code># Update from default GitHub source
crossfire -cu

# Update from specific URL
crossfire -cu https://example.com/crossfire.py

# Verify with SHA256 hash
crossfire -cu --sha256 abc123def456...</code></pre>
    
    <h4>Configuration</h4>
    <pre><code># Show current configuration
crossfire --config

# JSON format
crossfire --json --config</code></pre>
    
    <h4>Setup</h4>
    <pre><code># Run initial setup (PATH, launcher)
crossfire --setup</code></pre>
    
    <h3>Output Modes</h3>
    
    <h4>Standard Mode</h4>
    <p>Human-readable output with colors and formatting:</p>
    <pre><code>[CrossFire] 📦 Installing package: numpy
↳ Attempting via Python (pip)...
✅ Installed 'numpy' via Python (pip)</code></pre>
    
    <h4>JSON Mode</h4>
    <p>Machine-parseable structured output:</p>
    <pre><code>{
  "package": "numpy",
  "success": true,
  "attempts": [
    {
      "manager": "pip",
      "result": {
        "ok": true,
        "code": 0,
        "stdout": "Successfully installed numpy-1.21.0",
        "stderr": ""
      }
    }
  ]
}</code></pre>
    
    <h4>Quiet Mode</h4>
    <p>Only errors and critical information:</p>
    <pre><code>✗ Failed to install 'nonexistent-package' with all available managers.</code></pre>
    
    <h4>Verbose Mode</h4>
    <p>Detailed operation information:</p>
    <pre><code>[CrossFire] 📦 Installing package: numpy
[CrossFire] Running: python -m pip install numpy
[CrossFire] Will try managers in this order:
[CrossFire]   • Python (pip)
[CrossFire]   • APT
[CrossFire] ↳ Attempting via Python (pip)...
[CrossFire] ✅ Installed 'numpy' via Python (pip)</code></pre>
  </div>
  
  <div class="section" id="package-manager-integration">
    <h2>Package Manager Integration</h2>
    
    <h3>Manager Detection System</h3>
    <p>CrossFire uses a multi-layered approach to detect package managers:</p>
    
    <h4>1. Binary Availability Check</h4>
    <pre><code>def is_installed(manager_name: str) -> bool:
    meta = PACKAGE_MANAGERS.get(manager_name, {})
    manager_cmds = meta.get("manager", [])

    for cmd_list in manager_cmds:
        if cmd_list and shutil.which(cmd_list[0]):
            # Binary exists, now verify it works
            check_cmd = meta.get("check_cmd")
            if check_cmd:
                result = run_command(check_cmd, timeout=10)
                return result.ok</code></pre>
    
    <h4>2. Functional Verification</h4>
    <p>Each manager is tested with a simple command to ensure it's working:</p>
    <table>
      <thead>
        <tr>
          <th>Manager</th>
          <th>Test Command</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>pip</td>
          <td><code>pip --version</code></td>
          <td>Verify pip responds</td>
        </tr>
        <tr>
          <td>npm</td>
          <td><code>npm --version</code></td>
          <td>Check npm installation</td>
        </tr>
        <tr>
          <td>brew</td>
          <td><code>brew --version</code></td>
          <td>Test Homebrew</td>
        </tr>
        <tr>
          <td>apt</td>
          <td><code>apt --version</code></td>
          <td>Verify APT</td>
        </tr>
      </tbody>
    </table>
    
    <h4>3. Caching System</h4>
    <p>Manager detection results are cached to avoid repeated expensive checks:</p>
    <pre><code>_installed_cache: Dict[str, bool] = {}

def is_installed(manager_name: str) -> bool:
    if manager_name in _installed_cache:
        return _installed_cache[manager_name]
    # ... perform detection ...
    _installed_cache[manager_name] = result
    return result</code></pre>
    
    <h3>Installation Strategy</h3>
    <p>CrossFire uses intelligent manager selection based on multiple factors:</p>
    
    <h4>1. Package Type Heuristics</h4>
    <pre><code>def _looks_like_python_pkg(pkg: str) -> bool:
    python_indicators = ["==", ">=", "<=", "~=", "!=", "[", "]"]
    if any(indicator in pkg for indicator in python_indicators):
        return True

    python_common = ["django", "flask", "numpy", "pandas"]
    return any(pkg.lower().startswith(prefix) for prefix in python_common)

def _looks_like_npm_pkg(pkg: str) -> bool:
    return pkg.startswith("@") or pkg.lower() in ["express", "react", "vue"]</code></pre>
    
    <h4>2. Platform-Specific Priority</h4>
    <pre><code>def _system_manager_priority() -> List[str]:
    ot = _os_type()

    if ot == "macos":
        return ["brew", "snap", "flatpak"]
    elif ot == "windows":
        return ["winget", "choco"]
    elif ot == "linux":
        # Detect specific Linux package manager
        linux_managers = [
            ("apt", ["apt", "apt-get"]),
            ("dnf", ["dnf"]),
            ("yum", ["yum"]),
            ("pacman", ["pacman"]),
        ]
        # Return first available + universal managers
        return [detected_manager, "snap", "flatpak"]</code></pre>
    
    <h4>3. Installation Command Generation</h4>
    <p>Each manager has a dedicated command builder:</p>
    <pre><code>MANAGER_INSTALL_HANDLERS = {
    "pip": lambda pkg: [sys.executable, "-m", "pip", "install", pkg],
    "npm": lambda pkg: ["npm", "install", "-g", pkg],
    "apt": lambda pkg: ["sudo", "apt", "install", "-y", pkg],
    "brew": lambda pkg: ["brew", "install", pkg],
    # ... more handlers
}</code></pre>
    
    <h3>Python Package Management</h3>
    
    <h4>Multi-Python Support</h4>
    <p>CrossFire intelligently handles multiple Python installations:</p>
    <pre><code>def _get_python_commands() -> List[List[str]]:
    candidates = []

    # Current Python interpreter (highest priority)
    if sys.executable:
        candidates.append([sys.executable, "-m", "pip"])

    # System Python variants
    for exe_name in ("python3", "python", "py"):
        exe_path = shutil.which(exe_name)
        if exe_path and exe_path != sys.executable:
            candidates.append([exe_path, "-m", "pip"])

    # Direct pip commands
    for pip_name in ("pip3", "pip"):
        pip_path = shutil.which(pip_name)
        if pip_path:
            candidates.append([pip_path])

    return candidates</code></pre>
    <p>This ensures CrossFire works with:</p>
    <ul>
      <li>Virtual environments</li>
      <li>Multiple Python versions</li>
      <li>System-wide Python installations</li>
      <li>Alternative Python distributions (Anaconda, PyPy)</li>
    </ul>
    
    <h3>Error Recovery</h3>
    
    <h4>Graceful Fallback Chain</h4>
    <p>When one manager fails, CrossFire automatically tries alternatives:</p>
    <pre><code>def install_package(pkg: str, preferred_manager: Optional[str] = None):
    candidates = _ordered_install_manager_candidates(pkg, installed)
    attempts = []

    for manager in candidates:
        try:
            cmd = MANAGER_INSTALL_HANDLERS[manager](pkg)
            result = run_command(cmd, timeout=1800)
            attempts.append((manager, result))

            if result.ok:
                return (True, attempts)  # Success!
except Exception as e:
            attempts.append((manager, RunResult(False, -1, "", str(e))))

    return (False, attempts)  # All managers failed</code></pre>
    
    <h4>Intelligent Error Messages</h4>
    <p>CrossFire extracts meaningful error messages from manager output:</p>
    <pre><code>err_msg = (res.err or res.out).strip()
if err_msg:
    error_lines = err_msg.splitlines()
    relevant_error = error_lines[-1]  # Usually the most important
    if len(relevant_error) > 180:
        relevant_error = relevant_error[:177] + "..."</code></pre>
  </div>
  
  <div class="section" id="system-detection">
    <h2>System Detection</h2>
    
    <h3>Cross-Platform Compatibility</h3>
    <p>CrossFire adapts its behavior based on the detected operating system:</p>
    
    <h4>Windows-Specific Handling</h4>
    <pre><code>if OS_NAME == "Windows":
    creation_flags = subprocess.CREATE_NO_WINDOW  # Hide console windows
    # Use .bat files for launchers
    # Handle path separators correctly
    # Use Windows package managers (winget, choco)</code></pre>
    
    <h4>macOS-Specific Features</h4>
    <pre><code>if OS_NAME == "Darwin":
    DISTRO_NAME = "macOS"
    DISTRO_VERSION = platform.mac_ver()[0]
    # Prefer Homebrew for package management
    # Use .bash_profile over .bashrc</code></pre>
    
    <h4>Linux Distribution Detection</h4>
    <pre><code>try:
    import distro
    DISTRO_NAME = distro.id()        # ubuntu, fedora, arch, alpine
    DISTRO_VERSION = distro.version() # 20.04, 35, rolling
except Exception:
    # Fallback detection methods
    DISTRO_NAME = OS_NAME.lower()</code></pre>
    
    <h3>Architecture Detection</h3>
    <pre><code>ARCH = platform.architecture()[0]  # '32bit' or '64bit'</code></pre>
    <p>This affects:</p>
    <ul>
      <li>Package manager availability</li>
      <li>Package selection for architecture-specific software</li>
      <li>Installation paths and methods</li>
    </ul>
    
    <h3>Shell Detection and Integration</h3>
    <p>CrossFire detects and integrates with various shells:</p>
    
    <h4>Shell-Specific PATH Configuration</h4>
    <pre><code>def _get_shell_rc_file() -> str:
    shell = os.environ.get("SHELL", "")

    if shell.endswith("zsh"):
        return "~/.zshrc"
    elif shell.endswith("bash"):
        return "~/.bashrc" if OS_NAME != "Darwin" else "~/.bash_profile"
    elif shell.endswith("fish"):
        return "~/.config/fish/config.fish"
    else:
        return "~/.profile"  # Universal fallback</code></pre>
    
    <h4>Shell-Specific Syntax</h4>
    <pre><code>if rc_file.endswith("config.fish"):
    export_line = f'set -gx PATH "{script_dir}" $PATH'  # Fish syntax
else:
    export_line = f'export PATH="{script_dir}:$PATH"'   # POSIX syntax</code></pre>
  </div>
  
  <div class="section" id="advanced-features">
    <h2>Advanced Features</h2>
    
    <h3>Self-Update System</h3>
    <p>CrossFire includes a sophisticated self-update mechanism with security features:</p>
    
    <h4>Security Validation</h4>
    <pre><code>ALLOWED_UPDATE_HOSTS = {"github.com", "raw.githubusercontent.com", "githubusercontent.com"}
MAX_UPDATE_SIZE = 10 * 1024 * 1024  # 10MB limit

def _validate_update_url(url: str) -> None:
    parsed = urllib.parse.urlparse(url)
    host = parsed.netloc.lower()
    if not any(allowed in host for allowed in ALLOWED_UPDATE_HOSTS):
        raise ValueError(f"Update host '{host}' not in allowlist")</code></pre>
    
    <h4>Multi-Threaded Downloads</h4>
    <p>For faster updates, CrossFire can download files in parallel chunks:</p>
    <pre><code>def download_update(url: str, timeout: int = 60) -> bytes:
    # 1. Get file size with HEAD request
    with urllib.request.urlopen(head_req) as response:
        content_length = int(response.headers.get('Content-Length', 0))

    # 2. Calculate optimal chunk size
    num_chunks = min(4, max(2, os.cpu_count() or 1))
    chunk_size = content_length // num_chunks

    # 3. Download chunks in parallel
    with ThreadPoolExecutor(max_workers=num_chunks) as executor:
        # Submit download tasks for each chunk
        # Collect and reassemble results</code></pre>
    
    <h4>Atomic Updates</h4>
    <p>Updates use atomic file operations to prevent corruption:</p>
    <pre><code>def cross_update(url: str, verify_sha256: Optional[str] = None) -> bool:
    # 1. Download to temporary file
    with tempfile.NamedTemporaryFile(delete=False) as tmp_file:
        tmp_file.write(update_data)
        temp_path = tmp_file.name

    # 2. Verify integrity (if hash provided)
    if verify_sha256:
        actual_hash = hashlib.sha256(update_data).hexdigest()
        if actual_hash != expected_hash:
            raise ValueError("SHA256 mismatch")

    # 3. Create backup
    shutil.copy2(current_file, backup_file)

    # 4. Atomic replacement
    os.replace(temp_path, current_file)

    # 5. Verify update worked
    result = run_command([sys.executable, current_file, "--version"])
    if not result.ok:
        # Restore from backup
        shutil.copy2(backup_file, current_file)
        raise Exception("Update verification failed")</code></pre>
    
    <h3>Health Check System</h3>
    <p>The health check system provides comprehensive analysis of system state:</p>
    
    <h4>Manager Health Assessment</h4>
    <pre><code>def health_check() -> Dict[str, any]:
    health = {
        "overall_status": "healthy",  # healthy, warning, critical
        "issues": [],
        "recommendations": [],
        "manager_health": {}
    }

    for manager, status in status_info.items():
        manager_health = {"status": status, "issues": [], "working": False}

        if status == "Installed":
            # Test basic functionality
            result = run_command([manager, "--version"], timeout=5)
            manager_health["working"] = result.ok
            if result.ok:
                manager_health["version"] = result.out.strip()</code></pre>
    
    <h4>System Resource Monitoring</h4>
    <pre><code># Check disk space
result = run_command(["df", "-h", os.path.expanduser("~")])
usage_percent = extract_usage_percentage(result.out)
if int(usage_percent) > 90:
    health["issues"].append(f"Low disk space: {usage_percent}% used")
    health["recommendations"].append("Consider running 'crossfire --cleanup'")</code></pre>
    
    <h4>Intelligence Recommendations</h4>
    <p>The system provides actionable recommendations based on detected issues:</p>
    <ul>
      <li><b>No Package Managers</b>: Suggests installing pip, npm, or system manager</li>
      <li><b>Outdated Managers</b>: Recommends running updates</li>
      <li><b>Low Disk Space</b>: Suggests cleanup operations</li>
      <li><b>Broken Installations</b>: Provides specific fix instructions</li>
    </ul>
    
    <h3>Statistics Collection</h3>
    <p>CrossFire collects comprehensive system statistics:</p>
    
    <h4>Package Count Analysis</h4>
    <pre><code>def get_system_stats() -> Dict[str, any]:
    stats = {
        "system": {
            "os": OS_NAME,
            "distro": DISTRO_NAME,
            "python_version": platform.python_version(),
        },
        "managers": {},
        "disk_usage": {}
    }

    # Count packages for each manager
    for manager in installed_managers:
        if manager == "Python":
            result = run_command([sys.executable, "-m", "pip", "list"])
            count = len(result.out.strip().split('\n')) - 2  # Remove headers
            stats["managers"][manager]["package_count"] = count</code></pre>
    
    <h4>Cache Usage Analysis</h4>
    <pre><code>cache_dirs = {
    "pip": "~/.cache/pip",
    "npm": "~/.npm",
    "brew": "/usr/local/var/homebrew",
    "apt": "/var/cache/apt"
}

for manager, cache_dir in cache_dirs.items():
    expanded_dir = os.path.expanduser(cache_dir)
    if os.path.exists(expanded_dir):
        result = run_command(["du", "-sh", expanded_dir])
        if result.ok:
            stats["disk_usage"][manager] = result.out.split('\t')[0]</code></pre>
    
    <h3>System Cleanup</h3>
    <p>The cleanup system removes unnecessary files from multiple sources:</p>
    
    <h4>Manager-Specific Cleanup</h4>
    <pre><code>cleanup_commands = {
    "pip": [sys.executable, "-m", "pip", "cache", "purge"],
    "npm": ["npm", "cache", "clean", "--force"],
    "brew": ["brew", "cleanup", "--prune=all"],
    "apt": "sudo apt autoremove -y && sudo apt autoclean",
    "dnf": ["sudo", "dnf", "clean", "all"],
    "yum": ["sudo", "yum", "clean", "all"],
    "pacman": ["sudo", "pacman", "-Sc", "--noconfirm"]
}</code></pre>
    
    <h4>Concurrent Cleanup Execution</h4>
    <p>Cleanup operations run in parallel for efficiency:</p>
    <pre><code>def cleanup_system() -> Dict[str, Dict[str, str]]:
    with ThreadPoolExecutor(max_workers=4) as executor:
        future_to_manager = {
            executor.submit(run_cleanup, manager, cmd): manager
            for manager, cmd in cleanup_commands.items()
            if is_installed(manager)
        }

        for future in as_completed(future_to_manager):
            manager = future_to_manager[future]
            result = future.result()
            # Process cleanup result</code></pre>
  </div>
  
  <div class="section" id="configuration">
    <h2>Configuration</h2>
    
    <h3>Configuration File Location</h3>
    <p>CrossFire stores configuration in platform-appropriate locations:</p>
    <pre><code>def get_config_path() -> str:
    if OS_NAME == "Windows":
        config_dir = os.path.expanduser("~/AppData/Local/CrossFire")
    else:
        config_dir = os.path.expanduser("~/.config/crossfire")

    os.makedirs(config_dir, exist_ok=True)
    return os.path.join(config_dir, "config.json")</code></pre>
    <p><b>Locations</b>:</p>
    <ul>
      <li><b>Windows</b>: <code>%LOCALAPPDATA%\CrossFire\config.json</code></li>
      <li><b>macOS/Linux</b>: <code>~/.config/crossfire/config.json</code></li>
    </ul>
    
    <h3>Configuration Schema</h3>
    <pre><code>{
  "preferred_managers": {
    "python_packages": "pip",
    "node_packages": "npm",
    "system_packages": "brew"
  },
  "auto_cleanup": false,
  "timeout": 600,
  "max_retries": 1,
  "color_output": true,
  "update_check_interval": 86400,
  "download_concurrency": 4,
  "cache_expiry": 3600
}</code></pre>
    
    <h3>Configuration Options</h3>
    <table>
      <thead>
        <tr>
          <th>Option</th>
          <th>Type</th>
          <th>Default</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><code>preferred_managers</code></td>
          <td>Object</td>
          <td><code>{}</code></td>
          <td>Manager preferences by package type</td>
        </tr>
        <tr>
          <td><code>auto_cleanup</code></td>
          <td>Boolean</td>
          <td><code>false</code></td>
          <td>Automatically clean caches after operations</td>
        </tr>
        <tr>
          <td><code>timeout</code></td>
          <td>Integer</td>
          <td><code>600</code></td>
          <td>Default command timeout in seconds</td>
        </tr>
        <tr>
          <td><code>max_retries</code></td>
          <td>Integer</td>
          <td><code>1</code></td>
          <td>Maximum retry attempts for failed commands</td>
        </tr>
        <tr>
          <td><code>color_output</code></td>
          <td>Boolean</td>
          <td><code>true</code></td>
          <td>Enable colored terminal output</td>
        </tr>
        <tr>
          <td><code>update_check_interval</code></td>
          <td>Integer</td>
          <td><code>86400</code></td>
          <td>Seconds between update checks</td>
        </tr>
        <tr>
          <td><code>download_concurrency</code></td>
          <td>Integer</td>
          <td><code>4</code></td>
          <td>Max concurrent download threads</td>
        </tr>
        <tr>
          <td><code>cache_expiry</code></td>
          <td>Integer</td>
          <td><code>3600</code></td>
          <td>Manager detection cache lifetime</td>
        </tr>
      </tbody>
    </table>
    
    <h3>Configuration Management</h3>
    
    <h4>Loading Configuration</h4>
    <pre><code>def load_config() -> Dict[str, any]:
    default_config = {
        "preferred_managers": {},
        "auto_cleanup": False,
        # ... more defaults
    }

    try:
        if os.path.exists(config_path):
            with open(config_path, 'r', encoding='utf-8') as f:
                config = json.load(f)

                # Merge with defaults
                for key, value in default_config.items():
                    config.setdefault(key, value)
                return config
    except Exception as e:
        if LOG.verbose:
            cprint(f"Config load failed: {e}", "WARNING")

    return default_config</code></pre>
    
    <h4>Saving Configuration...</h4>
  </div>
  <div class="section" id="error-handling--recovery">
    <h2>Error Handling & Recovery</h2>
    <p>CrossFire's design prioritizes graceful failure and user-friendly error reporting. The goal is to provide actionable feedback and, where possible, to recover from transient issues automatically.</p>
    
    <h3>Failure Modes</h3>
    <ol>
      <li><b>Command Execution Failure</b>: A command returns a non-zero exit code. CrossFire logs the full command and output, then attempts an alternative if available.</li>
      <li><b>Timeout Errors</b>: A command hangs. The system terminates the process and logs a timeout error, providing a clear message to the user.</li>
      <li><b>Permission Errors</b>: An operation fails due to insufficient permissions. CrossFire checks for this and suggests the user run the command with administrator/root privileges.</li>
      <li><b>Connectivity Issues</b>: Network operations fail. The system uses a retry mechanism with exponential backoff to handle transient network problems.</li>
      <li><b>Integrity Check Failure</b>: A downloaded file's checksum doesn't match the expected value. The file is deleted, and a clear error message is shown, preventing the installation of a corrupted package.</li>
    </ol>
    
    <h3>Recovery Mechanisms</h3>
    <ul>
      <li><b>Automatic Fallback</b>: If a preferred package manager fails, CrossFire will automatically try other applicable managers in a predefined order.</li>
      <li><b>Retry Logic</b>: The <code>run_command</code> function includes a retry loop. By default, it retries once after a brief delay. This is configurable via the <code>max_retries</code> setting.</li>
      <li><b>Transactional Operations</b>: Critical operations, such as the self-update process, are designed to be atomic. If the update fails at any point, the original file is restored from a temporary backup, leaving the system in a consistent state.</li>
    </ul>
    <p>The modular design makes it easy to extend CrossFire with new package managers, custom functionality, and platform-specific optimizations. The comprehensive error handling ensures operations fail gracefully while providing actionable feedback to users.</p>
  </div>
  <div class="section" id="security-considerations">
    <h2>Security Considerations</h2>
    <p>Security is a core design principle of CrossFire. The CLI is built with several measures to mitigate common risks associated with executing external commands and downloading files from the internet.</p>
    
    <h3>Secure Update Mechanism</h3>
    <ul>
      <li><b>Allowlist Validation</b>: CrossFire only downloads updates from a predefined list of trusted hosts (e.g., <code>github.com</code>) to prevent man-in-the-middle attacks.</li>
      <li><b>Integrity Verification</b>: All self-updates can be verified against a SHA256 checksum. If the hash of the downloaded file doesn't match the expected hash, the update is aborted.</li>
      <li><b>Atomic Updates</b>: The update process uses a temporary file and atomic file replacement to prevent the main script from being corrupted if the process is interrupted.</li>
    </ul>
    
    <h3>Command Execution Safety</h3>
    <ul>
      <li><b>Isolated Environment</b>: External commands are executed with a minimal set of environment variables to reduce potential side effects and vulnerabilities.</li>
      <li><b>Sanitization</b>: User input is sanitized before being passed to external commands to prevent command injection attacks.</li>
    </ul>
    
    <h3>Permission Handling</h3>
    <p>CrossFire provides clear guidance on when elevated privileges are required. It avoids using <code>sudo</code> or other privilege elevation commands automatically unless explicitly configured or required by a known manager (e.g., APT).</p>
  </div>
  <div class="section" id="performance--optimization">
    <h2>Performance & Optimization</h2>
    <p>CrossFire is optimized for speed and efficiency, particularly in its use of concurrency and caching.</p>
    
    <h3>Concurrency</h3>
    <ul>
      <li><b>Parallel Status Checks</b>: When listing managers, CrossFire checks the status of all available managers concurrently to minimize latency.</li>
      <li><b>Concurrent Updates</b>: The <code>-um ALL</code> command uses a thread pool to update multiple package managers simultaneously.</li>
      <li><b>Multi-threaded Downloads</b>: Large file downloads (e.g., for self-updates) are split into chunks and downloaded in parallel to improve speed.</li>
    </ul>
    
    <h3>Caching</h3>
    <ul>
      <li><b>Manager Detection Cache</b>: The results of manager availability checks are cached for a configurable period (default: 1 hour) to avoid re-running expensive checks on subsequent commands.</li>
      <li><b>Package Cache</b>: CrossFire leverages the native caching mechanisms of the underlying package managers (pip, npm, apt, etc.) to avoid re-downloading packages.</li>
    </ul>
    
    <h3>Minimizing External Calls</h3>
    <p>The system is designed to minimize the number of external process calls, which are relatively slow. Where possible, it uses Python's standard library or cached results instead.</p>
  </div>
  <div class="section" id="troubleshooting">
    <h2>Troubleshooting</h2>
    <p>This section provides solutions to common issues users might encounter.</p>
    
    <h3>Installation Issues</h3>
    <ul>
      <li><b><code>command not found</code></b>: Ensure CrossFire's directory is in your system's PATH. Run <code>crossfire --setup</code> or follow the manual installation steps.</li>
      <li><b>Permission Denied</b>: Run the command with elevated privileges (<code>sudo</code> on Linux/macOS, or as Administrator on Windows).</li>
    </ul>
    
    <h3>Package Management Issues</h3>
    <ul>
      <li><b>Installation Failed</b>: If a package fails to install, try a different manager using the <code>--manager</code> flag. For example: <code>crossfire -i package_name --manager pip</code>.</li>
      <li><b>Manager is Not Detected</b>: Ensure the manager is correctly installed and in your system's PATH. If it's a non-standard installation, you may need to add it to your PATH.</li>
    </ul>
    
    <h3>General Issues</h3>
    <ul>
      <li><b>"Freezing" or Hanging</b>: Use the <code>--timeout</code> option to set a shorter timeout for commands. This can help identify unresponsive network connections or processes.</li>
      <li><b>Unexpected Behavior</b>: Run the command with the <code>-v</code> or <code>--verbose</code> flag to see detailed logs, which can help pinpoint the cause of the problem.</li>
    </ul>
  </div>
  <div class="section" id="development--extension">
    <h2>Development & Extension</h2>
    <p>CrossFire's architecture is designed to be easily extensible. Developers can contribute by adding support for new package managers, new commands, or improving existing functionality.</p>
    
    <h3>Key Takeaways</h3>
    <ul>
      <li><b>Universal Interface</b>: One tool for all package management needs</li>
      <li><b>Intelligent Selection</b>: Automatic choice of optimal package managers</li>
      <li><b>Robust Operation</b>: Handles failures gracefully with comprehensive fallbacks</li>
      <li><b>Cross-Platform</b>: Works consistently across Windows, macOS, and Linux</li>
      <li><b>Extensible Design</b>: Easy to add new managers and functionality</li>
      <li><b>Production Ready</b>: Comprehensive error handling, logging, and monitoring</li>
    </ul>
    
    <h3>Adding a New Package Manager</h3>
    <p>To add a new manager, you typically need to:</p>
    <ol>
      <li>Define its properties in the central managers dictionary (e.g., name, platform support, commands).</li>
      <li>Implement a function to handle its installation, removal, or update logic.</li>
      <li>(Optional) Add a heuristic function to help CrossFire intelligently select it for certain package types.</li>
    </ol>
    
    <h3>Future Considerations</h3>
    <p>CrossFire's architecture supports future enhancements including:</p>
    <ul>
      <li>Plugin system for third-party extensions</li>
      <li>Remote package repository support</li>
      <li>Integration with containerization systems</li>
      <li>Advanced dependency resolution</li>
      <li>Package vulnerability scanning</li>
      <li>Enterprise policy enforcement</li>
    </ul>
    <p>The solid foundation provided by CrossFire 3.0.0 ensures it can evolve to meet future package management challenges while maintaining backward compatibility and operational reliability.</p>
  </div>
  <footer>
    &copy; 2025 CrossFire CLI | <a href="forum.html">Community Forum</a>
  </footer>
</div>
</body>
</html>
